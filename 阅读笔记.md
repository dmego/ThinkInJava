# Java 编程思想阅读笔记

## 第 1 章 对象导论



## 第 2 章 一切都是对象



## 第 3 章 操作符

### 操作符

- 操作符作用于一个操作数，生成一个新值。另外有些操作符可能会改变操作数自身的值，这被称为`副作用`。
- 几乎所有的操作符只能操作`基本类型`，例外的操作符是`=`，`==`，`!=`，这些操作符能操作所有对象。
- `String` 类支持 `+` 和 `+=` 操作。

### 优先级

- 先乘除后加减
- 如果忘记优先级规则，应该用括号明确规定计算顺序

### 赋值

- 赋值使用`=`，意思是`取右边的值（可以是任何常数、变量或者表达式，只要能生成一个值就行），把它赋值给左边（左边必须是一个明确的已命名的变量）`。
- 常数不能作为左值
- 基本类型的赋值操作是直接将一个地方的内容复制到另一个地方
- 对象的赋值操作其实复制的是一个对象的引用，但是引用指向的对象还是同一个对象——`别名现象`
- 在方法调用中也会遇到`别名问题`，因为在参数传递过程中，实际上传递的是对象的引用

### 算数操作符

- `+`、`-`、`*`、`/`、`%`。（`%`是取模操作符，从整数除法中产生余数）
- 整数除法会直接去掉小数位，不会进行四舍五入
- `Random`类对象在创建过程中如果没有传递任何参数作为随机数生成器的种子，那么将会默认使用当前时间作为种子。
- 一元加`+`、一元减`-`操作符可以让较小类型（如`byte、short`）的操作数提升为`int`类型，不过需要强制转换。

### 自动递增和递减

- 前缀递增`++a`和前缀递减`--a`会先执行运算，再生成值，也就是说先是`++a`的值加`1`，然后`a`的值才加`1`。
- 后缀递增`a++`和递减`a--`和前缀正好相反，先`a`的值加`1`，然后才是`a++`的值加`1`。也就是在运算执行前就会得到值。
- 它们是除了那些涉及赋值操作的操作符以外，唯一具有`副作用`的操作符，也就是说他们会改变操作数，而不仅仅是使用他们的值。

### 关系操作符

- 关系操作符生成一个`boolean`类型的结果，计算的是操作数之间的关系。
- 主要有`>`、`<`、`>=`、`<=`、`==`、`!=`等。
- `==`和`!=`同样适用于所有对象，因为他们比较的是对象的引用（尽管两个对象的内容一样，但是对象的引用不同，使用`==`时为`false`）。
- 如果想要比较两个对象的实际内容是否相同，可以使用`equals()`方法。由于`equals()`方法默认比较的还是引用，所以除非我们在自己的新类中覆盖这个方法，否则还是无法得到正确结果。
- 大多数 Java 类库都实现了`equals()`方法，以便用来比较对象的内容而不是引用。
- 基本类型不能用`equals()`来判断，可以直接使用`==`和`!=`。

### 逻辑操作符

- 逻辑操作符`与（&&）`、`或（||）`、`非（!)`，能根据参数的逻辑关系，生成一个布尔值。
- 逻辑操作符只可应用于布尔值，不可以将一个非布尔值当做布尔值在逻辑表达式中使用，这和`C/C++`中有所不同，在`C/C++`逻辑表达式中可以使用整数。
- 如果在该使用`String`值的地方使用了布尔值，布尔值会自动转换成对应的文本形式（`true/false`）。
- **短路现象**：一旦明确无误确定整个表达式的值，就不再计算表达式余下的部分了。例如在表达式 `test(1) && test(2) && test(3)`，中，如果`test(1)`计算出来为`false`，那么将不会计算`test(2)`和`test(3)`。（如果所有的逻辑表达式都有一部分不必计算，那将获得潜在的性能提升）。

### 直接常量

- 直接常量后缀字符标志了它的类型。`L/l`表示`long`、`F/f`表示`float`、`D/d`表示`double`。
- 十六进制以前缀`0x/0X`，后面跟随`0-9`或小写（大写）的`a-f`来表示。
- 八进制数由前缀`0`以及后续的`0~7`的数字来表示。
- **指数计数法**：`1.39e-43`表示`1.39x10^-43`，而`1.39e3`则表示`1.39x10^3`

### 按位操作符

- 按位操作符用来操作整数基本数据类型中的单个比特（bit）。按位操作符会对两个参数中对应的位执行布尔代数运算，最终生成一个结果。
  - 按位与`&`:两个参数的输入位都是`1`，则输出位也是`1`，否则是`0`，例如`1111 & 1010 = 1010`
  - 按位或`|`:输入位只要有一个是`1`，对应的输出位也是`1`，例如`1111 | 1010 = 1111`
  - 按位异或`^`:两个参数的位中，相同的结果为`0`，不同的结果为`1`，例如`1111 ^ 1010 = 0101`
  - 按位非`~`:按位取反操作，例如`~1010 = 0101`
- 按位操作符可与等号（=）联合使用，例如：`&=`、`|=`、`^=`，由于`~`是一元操作符，不能与`=`联合使用
- 对于布尔值，按位操作符和逻辑操作符具有相同的效果（不能执行`按位非`操作，对比下多了一个`按位异或`操作），只是它们不会中途`短路`。

### 移位操作符

- 移位操作符的运算对象也是二进制位，并且只可用来处理整数类型
  - 左移位操作符`<<`:将操作符左边的操作数`左移`右侧指定的位数（在低位补0），例如：`1010 << 2 = 101000`
  - `有符号`右移操作符`>>`:将操作符左边的操作数`右移`右侧指定的位数，右移操作符使用`符号扩展`，若符号为正，则在高位插入0；若符合为负，则在高位插入1。例如：`1010 >> 2 = 0010`、`11010 >> 2 = 11110`
  - `无符号`右移操作符`>>>`，它使用`零扩展`，无论正负，都在高位插入0；例如: `1010 >>> 2 = 0010`

- 如果对`byte`、`char`或`short`类型的数值进行移位操作，那么在移位之前会被转换成`int`类型，并且得到的结果也是`int`类型的。只有数值右端的低5位才有用，这样防止移位超过`int`类型所具有的位数（2^5 = 32 ，int 类型只有 32 位）。
- 若对`long`类型进行移位，最后会得到`long`类型的结果，此时只会用到数值右端的低6位，同样也是防止超过 long 类型的最大位数。
- 移位操作可以与`=`组合使用，例如：`<<=`、`>>=`、`>>>=`；但是在进行无符号右移位结合赋值操作时可能会出现问题：对`byte`或`short`类型进行右移位操作时，先转换成`int`类型，再进行位操作，操作完成后再赋值给原来的类型，这中间就要被`截断`，因为`int`类型大于`byte`和`short`类型，在这种情况下可能会得到`-1`的结果。
- 数字的二进制形式称为`有符号的二进制补码`。

### 三元操作符

- `boolean-exp ? value0 : value1`:如果布尔表达式（`boolean-exp`）为`true`，就计算`value0`的值并返回，如果表达式值为`false`，就计算`value1`的值并返回。
- 与普通的`if-else`语句一样，但是比较简练，也正是如此，如果频繁使用会让代码可读性变差

### 字符串操作符 + 和 +=

- 这个操作符在`Java`中主要用于连接不同的字符串
- `String + int + int + String`:在做输出时，经常使用 `+`操作符，这里就是用做字符串连接，这其中还涉及到类型转换，如果`+`前面是一个字符串类型，那么后面的所有类型都会自动转换为字符串类型，后面的`+`为连接操作符，而不是做算数运算。
- `S1 += S1`:将字符串`S2`追加到`S1`上
- `“”+int`:使用这种方式可以非常方便的将`int`类型转换为`String`类型。

### 类型转换操作符

- 类型转换（cast）原意是`模型锻造`，转换示例：`int i = 200; long l =(long)i; `。
- **窄化转换**：将容量较大的类型转换为容量较小的类型，例如`double`转`int`，这其中将会存在信息丢失的危险。在进行这样的转换时需要进行强制转换，也就是显示的进行转换。
- **扩展转换**：将容量较小的类型转换为容量较大的类型，例如`float`转`double`，对于这样的转换不需要显示的进行转换，Java会自动的进行类型转换。因为这其中不会涉及到信息丢失。
- **截尾和舍入**：在将`double`和`float`类型转换为整型时，总是对该数字进行`截尾处理`，也就是小数点后面的全部不要，如果想要进行四舍五入，可以使用`Math`中的`round()`方法。
- 通常，表达式中出现的最大数据类型决定了表达式最终结果的数据类型

### 注意点

- 如果对两个足够大的`int`类型进行乘法运算，结果会溢出，但是不会收到警告，异常或者是错误。
- 在进行`窄化转换`时要注意信息的丢失



## 第 4 章 控制执行流程



## 第 5 章 初始化与清理



## 第 6 章 访问权限控制



## 第 7 章 复用类

### 组合语法

- 组合就是在新的类中产生现有类的对象，也就是将对象引用置于新类中
- 初始化引用的位置：
  - 在定义对象的地方。这意味着他们总能在构造器调用之前被初始化
  - 在类的构造器中
  - 就在正要使用这些对象之前，这种方式被称为`惰性初始化`，在生成对象不值得或不必每次生成对象的情况下，这种方式可以减少额外的负担
  - 使用实例进行初始化

### 继承语法

- 当创建一个类时，总是在继承，因为所有的类都隐式地从`Java`的标准根类`Object`进行继承
- 继承使用关键字`extends`实现，继承后会得到基类中所有的域和方法
- 为了继承，一般规则是将所有的数据成员都指定为`private`，将所有方法指定为`public`
- `Java`中使用`super`关键字表示超类的意思，也就是基类或父类
- 继承并不只是复制基类的接口，当创建一个导出类（子类）的对象时，该对象包含了一个基类的子对象，这个子对象与你用基类直接创建的对象是一样的。区别是基类的子对象被包装在子类对象内部，而直接创建的来自于外部
- `Java`会自动在子类的构造器中插入对基类构造器的调用
- 构建过程是从基类“向外”扩散的，也就是先执行基类的构造器再执行子类的构造器
- 子类的默认构造器会先默认调用基类的默认构造器
- 如果基类提供了有参构造器，并且没有提供默认构造器，如果不在子类构造器中显式的调用基类有参构造器，将会出现编译错误

### 代理

- 代理是继承与组合之间的中庸之道，因为我们可以选择只提供在成员对象中的方法的某个子集，而不用像继承那样将父类中的所有成员和方法都继承下来。

```java
/*代理示例代码*/
public class A{
    void fun(int c){}
}

public class B{
    private A a = new A();
    //代理
    public void fun(int c){ a.fun(c); }
}
```

### 结合使用组合和继承

- 析构函数是一种在对象被销毁时可以被自动调用的函数
- **try{}finally{}**：`try{}`表示所谓的`保护区`，这意味着它需要被特殊处理。`finally`子句中的代码总是会执行
- 在执行清理方法时，首先执行类的所有特定的清理动作，其顺序同生成顺序相反（通常要求基类元素仍然存活）；然后调用基类的清理方法
- 如果`Java`的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（这一点与`C++`不同）
- `@Override`注解可以防止你在不想重载时意外地进行了重载

### 在组合与继承之间选择

- 在使用组合时，一般是在新类中嵌入一个现有类的`private`对象，让其实现所需要的功能。
- **is-a关系**：`is-a`（是一个）的关系是用继承来表达的
- **has-a关系**：`has-a`（有一个）的关系是用组合来表达的

### protected 关键字

- 就类用户而言，这是`private`的，但是对于任何继承于此类的子类或其他任何位于同一包下的类来说，却是可以访问的
- 尽管可以创建`protected`域，但是最好的方式还是将域定义为`private`

### 向上转型

- 子类和父类之间的关系可以用一句话概括：子类是父类的一种类型
- 在程序中，我们可以将子类的引用转换为父类引用的动作，称之为`向上转型`
- 由导出类转型成基类，在继承图上是向上移动的，因此一般称为`向上转型`
- 只有在需要用到从新类向基类进行向上转型的时候，使用继承才是必须的

### final 关键字

- 使用`final`修饰通常指的是`这是无法改变的`
- 一个既是`static`又是`final`的域（也就是编译器常量，一般用大写表示）只占一段不能改变的存储空间
- 对于基本类型，`final`让数值恒定不变；对于对象引用，`final`使引用恒定不变，也就是说一旦一个引用初始化指向了一个对象，就无法再把它改为指向另一个对象。然而对于对象自身却是可以被修改的
- 一般定义一个常量的方式为：`public static final VAL_THREE`，`public`表示可以用于包外，`static`强调只有一份，`final`说明是一个常量；一般用大写字母表示，单词之间用下划线分割
- 不能因为某数据是`final`的就认为在编译时就可以知道它的值，常量的值可以在运行时确定
- 数组是另一种引用
- 空白`final`是指被声明为`final`但是又未给出初始值的域，一个类中的`final`域可以做到根据对象而有所不同
- 必须在域定义处或者在每个构造器中用表达式对`final`域进行赋值，这是`final`域在使用前总是被初始化的原因所在
- `Java`允许在参数列表中以声明的方式将参数指明为`final`，这意味着你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据
- 使用`final`方法有两个原因，一是把方法锁定，以防任何继承类修改它的含义；二是提高效率
- 类中所有的`private`方法都隐式地指定为是`final`的，由于无法取用`private`方法，所以也就无法覆盖它。
- “覆盖”是只有在某方法是基类的接口的一部分时才会出现
- 如果某方法为`private`，他就不是基类接口的一部分，它仅是一些隐藏于类中的代码，只不过具有相同的名称罢了
- 当将某个类的整体定义为`final`时，表明这个类无法被继承
- 由于`final`类禁止继承，所以`final`类中所有的方法都隐式地指定为`final`的

### 初始化及类的加载

- 每个类的编译代码都存在于它自己的独立文件中，该文件只在需要使用程序代码时才会被加载
- 一个类的代码只有在创建该类的第一个对象时才会被加载，或者当访问该类的`static`域或`static`方法时也会被加载
- 初次使用之处也是`static`初始化发生之处，所有的`static`对象和`static`代码都会在加载时按照程序中的顺序依次进行初始化。
- 定义为`static`的东西只会被初始化一次
- 在继承中，当创建第一个子类对象时加载的顺序为：
  - 首先进行加载的是基类，确切的说是根基类中的`static`域首先进行加载初始化
  - 然后是子类中的`static`域进行初始化
  - 所有类加载完成后，就可以创建对象了。这时对象中所有的基本类型和引用类型都会被设置成默认值
  - 接着调用基类中的构造器，完成之后调用子类的构造器
  - 在基类构造器完成之后，实例变量按照其次序被初始化，最后构造器的其余部分被执行


## 第 8 章 多态


## 第 9 章 接口

