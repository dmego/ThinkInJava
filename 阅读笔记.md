# Java 编程思想阅读笔记

## 第 1 章 对象导论



## 第 2 章 一切都是对象



## 第 3 章 操作符

### 操作符

- 操作符作用于一个操作数，生成一个新值。另外有些操作符可能会改变操作数自身的值，这被称为`副作用`。
- 几乎所有的操作符只能操作`基本类型`，例外的操作符是`=`，`==`，`!=`，这些操作符能操作所有对象。
- `String` 类支持 `+` 和 `+=` 操作。

### 优先级

- 先乘除后加减
- 如果忘记优先级规则，应该用括号明确规定计算顺序

### 赋值

- 赋值使用`=`，意思是`取右边的值（可以是任何常数、变量或者表达式，只要能生成一个值就行），把它赋值给左边（左边必须是一个明确的已命名的变量）`。
- 常数不能作为左值
- 基本类型的赋值操作是直接将一个地方的内容复制到另一个地方
- 对象的赋值操作其实复制的是一个对象的引用，但是引用指向的对象还是同一个对象——`别名现象`
- 在方法调用中也会遇到`别名问题`，因为在参数传递过程中，实际上传递的是对象的引用

### 算数操作符

- `+`、`-`、`*`、`/`、`%`。（`%`是取模操作符，从整数除法中产生余数）
- 整数除法会直接去掉小数位，不会进行四舍五入
- `Random`类对象在创建过程中如果没有传递任何参数作为随机数生成器的种子，那么将会默认使用当前时间作为种子。
- 一元加`+`、一元减`-`操作符可以让较小类型（如`byte、short`）的操作数提升为`int`类型，不过需要强制转换。

### 自动递增和递减

- 前缀递增`++a`和前缀递减`--a`会先执行运算，再生成值，也就是说先是`++a`的值加`1`，然后`a`的值才加`1`。
- 后缀递增`a++`和递减`a--`和前缀正好相反，先`a`的值加`1`，然后才是`a++`的值加`1`。也就是在运算执行前就会得到值。
- 它们是除了那些涉及赋值操作的操作符以外，唯一具有`副作用`的操作符，也就是说他们会改变操作数，而不仅仅是使用他们的值。

### 关系操作符

- 关系操作符生成一个`boolean`类型的结果，计算的是操作数之间的关系。
- 主要有`>`、`<`、`>=`、`<=`、`==`、`!=`等。
- `==`和`!=`同样适用于所有对象，因为他们比较的是对象的引用（尽管两个对象的内容一样，但是对象的引用不同，使用`==`时为`false`）。
- 如果想要比较两个对象的实际内容是否相同，可以使用`equals()`方法。由于`equals()`方法默认比较的还是引用，所以除非我们在自己的新类中覆盖这个方法，否则还是无法得到正确结果。
- 大多数 Java 类库都实现了`equals()`方法，以便用来比较对象的内容而不是引用。
- 基本类型不能用`equals()`来判断，可以直接使用`==`和`!=`。

### 逻辑操作符

- 逻辑操作符`与（&&）`、`或（||）`、`非（!)`，能根据参数的逻辑关系，生成一个布尔值。
- 逻辑操作符只可应用于布尔值，不可以将一个非布尔值当做布尔值在逻辑表达式中使用，这和`C/C++`中有所不同，在`C/C++`逻辑表达式中可以使用整数。
- 如果在该使用`String`值的地方使用了布尔值，布尔值会自动转换成对应的文本形式（`true/false`）。
- **短路现象**：一旦明确无误确定整个表达式的值，就不再计算表达式余下的部分了。例如在表达式 `test(1) && test(2) && test(3)`，中，如果`test(1)`计算出来为`false`，那么将不会计算`test(2)`和`test(3)`。（如果所有的逻辑表达式都有一部分不必计算，那将获得潜在的性能提升）。

### 直接常量

- 直接常量后缀字符标志了它的类型。`L/l`表示`long`、`F/f`表示`float`、`D/d`表示`double`。
- 十六进制以前缀`0x/0X`，后面跟随`0-9`或小写（大写）的`a-f`来表示。
- 八进制数由前缀`0`以及后续的`0~7`的数字来表示。
- **指数计数法**：`1.39e-43`表示`1.39x10^-43`，而`1.39e3`则表示`1.39x10^3`

### 按位操作符

- 按位操作符用来操作整数基本数据类型中的单个比特（bit）。按位操作符会对两个参数中对应的位执行布尔代数运算，最终生成一个结果。
  - 按位与`&`:两个参数的输入位都是`1`，则输出位也是`1`，否则是`0`，例如`1111 & 1010 = 1010`
  - 按位或`|`:输入位只要有一个是`1`，对应的输出位也是`1`，例如`1111 | 1010 = 1111`
  - 按位异或`^`:两个参数的位中，相同的结果为`0`，不同的结果为`1`，例如`1111 ^ 1010 = 0101`
  - 按位非`~`:按位取反操作，例如`~1010 = 0101`
- 按位操作符可与等号（=）联合使用，例如：`&=`、`|=`、`^=`，由于`~`是一元操作符，不能与`=`联合使用
- 对于布尔值，按位操作符和逻辑操作符具有相同的效果（不能执行`按位非`操作，对比下多了一个`按位异或`操作），只是它们不会中途`短路`。

### 移位操作符

- 移位操作符的运算对象也是二进制位，并且只可用来处理整数类型
  - 左移位操作符`<<`:将操作符左边的操作数`左移`右侧指定的位数（在低位补0），例如：`1010 << 2 = 101000`
  - `有符号`右移操作符`>>`:将操作符左边的操作数`右移`右侧指定的位数，右移操作符使用`符号扩展`，若符号为正，则在高位插入0；若符合为负，则在高位插入1。例如：`1010 >> 2 = 0010`、`11010 >> 2 = 11110`
  - `无符号`右移操作符`>>>`，它使用`零扩展`，无论正负，都在高位插入0；例如: `1010 >>> 2 = 0010`

- 如果对`byte`、`char`或`short`类型的数值进行移位操作，那么在移位之前会被转换成`int`类型，并且得到的结果也是`int`类型的。只有数值右端的低5位才有用，这样防止移位超过`int`类型所具有的位数（2^5 = 32 ，int 类型只有 32 位）。
- 若对`long`类型进行移位，最后会得到`long`类型的结果，此时只会用到数值右端的低6位，同样也是防止超过 long 类型的最大位数。
- 移位操作可以与`=`组合使用，例如：`<<=`、`>>=`、`>>>=`；但是在进行无符号右移位结合赋值操作时可能会出现问题：对`byte`或`short`类型进行右移位操作时，先转换成`int`类型，再进行位操作，操作完成后再赋值给原来的类型，这中间就要被`截断`，因为`int`类型大于`byte`和`short`类型，在这种情况下可能会得到`-1`的结果。
- 数字的二进制形式称为`有符号的二进制补码`。

### 三元操作符

- `boolean-exp ? value0 : value1`:如果布尔表达式（`boolean-exp`）为`true`，就计算`value0`的值并返回，如果表达式值为`false`，就计算`value1`的值并返回。
- 与普通的`if-else`语句一样，但是比较简练，也正是如此，如果频繁使用会让代码可读性变差

### 字符串操作符 + 和 +=

- 这个操作符在`Java`中主要用于连接不同的字符串
- `String + int + int + String`:在做输出时，经常使用 `+`操作符，这里就是用做字符串连接，这其中还涉及到类型转换，如果`+`前面是一个字符串类型，那么后面的所有类型都会自动转换为字符串类型，后面的`+`为连接操作符，而不是做算数运算。
- `S1 += S1`:将字符串`S2`追加到`S1`上
- `“”+int`:使用这种方式可以非常方便的将`int`类型转换为`String`类型。

### 类型转换操作符

- 类型转换（cast）原意是`模型锻造`，转换示例：`int i = 200; long l =(long)i; `。
- **窄化转换**：将容量较大的类型转换为容量较小的类型，例如`double`转`int`，这其中将会存在信息丢失的危险。在进行这样的转换时需要进行强制转换，也就是显示的进行转换。
- **扩展转换**：将容量较小的类型转换为容量较大的类型，例如`float`转`double`，对于这样的转换不需要显示的进行转换，Java会自动的进行类型转换。因为这其中不会涉及到信息丢失。
- **截尾和舍入**：在将`double`和`float`类型转换为整型时，总是对该数字进行`截尾处理`，也就是小数点后面的全部不要，如果想要进行四舍五入，可以使用`Math`中的`round()`方法。
- 通常，表达式中出现的最大数据类型决定了表达式最终结果的数据类型

### 注意点

- 如果对两个足够大的`int`类型进行乘法运算，结果会溢出，但是不会收到警告，异常或者是错误。
- 在进行`窄化转换`时要注意信息的丢失



## 第 4 章 控制执行流程



## 第 5 章 初始化与清理



## 第 6 章 访问权限控制



## 第 7 章 复用类

### 7.1 组合语法

- 组合就是在新的类中产生现有类的对象，也就是将对象引用置于新类中
- 初始化引用的位置：
  - 在定义对象的地方。这意味着他们总能在构造器调用之前被初始化
  - 在类的构造器中
  - 就在正要使用这些对象之前，这种方式被称为`惰性初始化`，在生成对象不值得或不必每次生成对象的情况下，这种方式可以减少额外的负担
  - 使用实例进行初始化

### 7.2 继承语法

- 当创建一个类时，总是在继承，因为所有的类都隐式地从`Java`的标准根类`Object`进行继承
- 继承使用关键字`extends`实现，继承后会得到基类中所有的域和方法
- 为了继承，一般规则是将所有的数据成员都指定为`private`，将所有方法指定为`public`
- `Java`中使用`super`关键字表示超类的意思，也就是基类或父类
- 继承并不只是复制基类的接口，当创建一个导出类（子类）的对象时，该对象包含了一个基类的子对象，这个子对象与你用基类直接创建的对象是一样的。区别是基类的子对象被包装在子类对象内部，而直接创建的来自于外部
- `Java`会自动在子类的构造器中插入对基类构造器的调用
- 构建过程是从基类“向外”扩散的，也就是先执行基类的构造器再执行子类的构造器
- 子类的默认构造器会先默认调用基类的默认构造器
- 如果基类提供了有参构造器，并且没有提供默认构造器，如果不在子类构造器中显式的调用基类有参构造器，将会出现编译错误

### 7.3 代理

- 代理是继承与组合之间的中庸之道，因为我们可以选择只提供在成员对象中的方法的某个子集，而不用像继承那样将父类中的所有成员和方法都继承下来。

```java
/*代理示例代码*/
public class A{
    void fun(int c){}
}

public class B{
    private A a = new A();
    //代理
    public void fun(int c){ a.fun(c); }
}
```

### 7.4 结合使用组合和继承

- 析构函数是一种在对象被销毁时可以被自动调用的函数
- **try{}finally{}**：`try{}`表示所谓的`保护区`，这意味着它需要被特殊处理。`finally`子句中的代码总是会执行
- 在执行清理方法时，首先执行类的所有特定的清理动作，其顺序同生成顺序相反（通常要求基类元素仍然存活）；然后调用基类的清理方法
- 如果`Java`的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（这一点与`C++`不同）
- `@Override`注解可以防止你在不想重载时意外地进行了重载

### 7.5 在组合与继承之间选择

- 在使用组合时，一般是在新类中嵌入一个现有类的`private`对象，让其实现所需要的功能。
- **is-a关系**：`is-a`（是一个）的关系是用继承来表达的
- **has-a关系**：`has-a`（有一个）的关系是用组合来表达的

### 7.6 protected 关键字

- 就类用户而言，这是`private`的，但是对于任何继承于此类的子类或其他任何位于同一包下的类来说，却是可以访问的
- 尽管可以创建`protected`域，但是最好的方式还是将域定义为`private`

### 7.7 向上转型

- 子类和父类之间的关系可以用一句话概括：子类是父类的一种类型
- 在程序中，我们可以将子类的引用转换为父类引用的动作，称之为`向上转型`
- 由导出类转型成基类，在继承图上是向上移动的，因此一般称为`向上转型`
- 只有在需要用到从新类向基类进行向上转型的时候，使用继承才是必须的

### 7.8 final 关键字

- 使用`final`修饰通常指的是`这是无法改变的`
- 一个既是`static`又是`final`的域（也就是编译器常量，一般用大写表示）只占一段不能改变的存储空间
- 对于基本类型，`final`让数值恒定不变；对于对象引用，`final`使引用恒定不变，也就是说一旦一个引用初始化指向了一个对象，就无法再把它改为指向另一个对象。然而对于对象自身却是可以被修改的
- 一般定义一个常量的方式为：`public static final VAL_THREE`，`public`表示可以用于包外，`static`强调只有一份，`final`说明是一个常量；一般用大写字母表示，单词之间用下划线分割
- 不能因为某数据是`final`的就认为在编译时就可以知道它的值，常量的值可以在运行时确定
- 数组是另一种引用
- 空白`final`是指被声明为`final`但是又未给出初始值的域，一个类中的`final`域可以做到根据对象而有所不同
- 必须在域定义处或者在每个构造器中用表达式对`final`域进行赋值，这是`final`域在使用前总是被初始化的原因所在
- `Java`允许在参数列表中以声明的方式将参数指明为`final`，这意味着你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据
- 使用`final`方法有两个原因，一是把方法锁定，以防任何继承类修改它的含义；二是提高效率
- 类中所有的`private`方法都隐式地指定为是`final`的，由于无法取用`private`方法，所以也就无法覆盖它。
- “覆盖”是只有在某方法是基类的接口的一部分时才会出现
- 如果某方法为`private`，他就不是基类接口的一部分，它仅是一些隐藏于类中的代码，只不过具有相同的名称罢了
- 当将某个类的整体定义为`final`时，表明这个类无法被继承
- 由于`final`类禁止继承，所以`final`类中所有的方法都隐式地指定为`final`的

### 7.9 初始化及类的加载

- 每个类的编译代码都存在于它自己的独立文件中，该文件只在需要使用程序代码时才会被加载
- 一个类的代码只有在创建该类的第一个对象时才会被加载，或者当访问该类的`static`域或`static`方法时也会被加载
- 初次使用之处也是`static`初始化发生之处，所有的`static`对象和`static`代码都会在加载时按照程序中的顺序依次进行初始化。
- 定义为`static`的东西只会被初始化一次
- 在继承中，当创建第一个子类对象时加载的顺序为：
  - 首先进行加载的是基类，确切的说是根基类中的`static`域首先进行加载初始化
  - 然后是子类中的`static`域进行初始化
  - 所有类加载完成后，就可以创建对象了。这时对象中所有的基本类型和引用类型都会被设置成默认值
  - 接着调用基类中的构造器，完成之后调用子类的构造器
  - 在基类构造器完成之后，实例变量按照其次序被初始化，最后构造器的其余部分被执行



## 第 8 章 多态

- 多态的作用是消除类型之间的耦合关系
- 多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要他们是从同一基类中导出的
- 这种区别是根据方法行为的不同而表现出来的，虽然这些方法都可以通过同一基类来调用
- 多态又被称为：动态绑定、后期绑定或运行时绑定

### 8.1 再论向上转型

- 把某个类的引用视为对其基类型的引用的做法称之为`向上转型`
- 向上转型可能会`缩小`导出类的接口，但是不会比基类的全部接口更窄

### 8.2 转机

-  将一个方法调用同一个方法主体关联起来被称作`绑定`
- 如果在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做`前期绑定`，例如：`C`只有前期绑定
- `后期绑定`：在运行时根据对象的类型进行绑定，也叫`动态绑定`或`运行时绑定`
- `Java`中除了`static`方法和`final`方法（`private`方法属于`final`方法）之外，其他所有方法都是后期绑定的。通常意味着后期绑定是自动发生的。
- 在编译时，编译器不需要获得任何特殊信息就能进行正确的调用。所有调用都是通过动态绑定实现
- 当我们将子类的引用置于基类的数组中时，他就会向上转型到基类类型
- 只有非`private`方法才能被覆盖，如果覆盖了`private`方法，编译不会报错，但是也不会按照期望执行
- 任何域访问操作都将由编译器解析，因此不是多态的。因为通常会将域设置为`private`，是不能直接访问的，也就不可能会是多态的
- 如果某个方法是静态的，那么他的行为就不具有多态性，因为静态方法是与类，而非单个对象相关联的

### 8.3 构造器与多态

- 构造器实际上是`static`方法，只不过是声明是隐式的，所以其不具有多态性
- 构造器会检查对象是否被正确构造
- 对象的销毁顺序应该和初始化顺序相反。对于字段，与声明的顺序相反。
- 首先应该对导出类进行清理，然后才是基类
- 从概念上讲，构造器的工作实际上是创建对象
- 程序初始化顺序：
  - 在其它任何事情发生之前，将分配对象的存储空间初始化为二进制的零（基本类型初始为`0`，对象初始化为`null`）
  - 调用基类的构造器
  - 按声明的顺序调用成员的初始化方法
  - 调用子类构造器的主体
- 编写构造器准则：用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其它方法。
- 在构造器内唯一能安全调用的方法是基类中的`final`方法（或`private`方法），因为这些方法不能被覆盖，也就不会出现问题。

### 8.4 协变返回类型

- 表示在子类中被覆盖方法可以返回基类方法的返回类型的某种导出类

### 8.5 用继承进行设计

- 当我们使用现成类来建立新类时，首先考虑的是`组合`而不是`继承`，因为`继承`在编译时就需要知道确切类型
- 我们不能在运行期间决定继承不同的对象，因为它要求在编译期间完全确定下来
- “用继承表达行为间的差异，并用字段表达状态上的变化”
- **is-a**：是一个关系。纯继承可以认为是一种`纯替代`，因为子类没有任何扩展，接口与基类完全一样
- **is-like-a**：像一个关系。扩展继承，子类还具有除继承或覆盖基类接口之外的其他扩展方法。
- 对于扩展继承，我们向上转型后就不能调用那些子类中的新方法
- `向下转型`：由基类转换为子类。向下转型是不安全的。
- 在`Java`中，所有转型都会进行检查。以保证确实是我们希望的那种类型。如果不是将会返回一个`ClassCastException`（类型转换异常），这种在运行期间对类型进行检查的行为称之为`运行时类型识别`（RTTI）

### 8.6 总结

- 多态是一种不能单独来看待的特性，相反它只能作为类关系“全景”中的一部分，与其他特性协同工作



##  第 9 章 接口

 ### 9.1 抽象类和抽象方法

- 抽象方法：仅有声明没有方法体。声明时加上关键字`abstract`
- 抽象类：如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。（否则，编译器会报错）
- 如果从一个抽象类继承，并且想要创建该新类的对象，那么必须在新类中为基类中所有抽象方法提供方法定义，如果不这样做，那么新类也必须声明为抽象的。当然编译器也会报错，然后提示我们这样做
- 一个抽象类并不需要将所有的方法都定义为抽象的，仅需要将所需要的方法声明为抽象的即可
- 抽象类是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层次结构向上移动

### 9.2 接口

- 定义一个接口使用`interface`关键字，一个接口相当于一个完全抽象的类
- 接口也可以包含域，但是这些域隐式地是`static`和`final`的
- 如果想要实现一个或一组接口，需要使用关键字`implements`
- 一旦实现了某个接口，该实现就变成了一个普通的类，可以按常规的方式去扩展它。
- 可以在接口中将方法显式的声明为`public`，即使你不这样做，它们也是`public`的。
- 如果将方法声明为`private`或`protected`的，编译器会报错。因为当该方法在继承的过程中，访问权限就被降低了

### 9.3 完全解耦

- 只要一个方法操作的是类而非接口，那么你就只能使用这个类或其子类
- 创建一个能够根据所传递的**参数对象**的不同而具有不用行为的**方法**，被称为策略模式。策略就是传递进去的参数对象
- 适配器设计模型：适配器中代码将接受你拥有的接口，并产生你所需要的接口
- 将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现，因此代码也就能更具有复用性

### 9.4 Java 中的多重继承

- 如果从一个非接口的类继承，那么只能继承一个类，其他的基元素都必须是接口
- 如果继承自一个具体类和多个接口，那么这个具体类必须放到前面，后面跟着才是接口
- 可以扩展接口，但是得到的只是另一个接口
- 使用接口的核心原因：为了能`向上转型`为多个基类型。另一个原因：防止客户端程序员创建该类的对象
- 如果想要创建不带任何方法和成员变量的基类，那么就应该选择接口而不是抽象类

### 9.5 通过基础来扩展接口

- 通过继承，很容易在接口中添加新的方法声明，还可以通过继承在新接口中组合多个接口

- 一般只可以将`extends`关键字用于单一类，但是可以引用多个基类接口，也就说可以使用`extends`来继承多个接口，使用逗号隔开即可
- 在打算组合的不同接口中使用相同的方法名通过会造成代码可读性混乱，尽量避免这种情况发生

### 9.6 适配接口

- 接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现
- 可以使用`interface`关键字来提供伪多重继承机制
- 让方法接受接口类型，是一种让任何类都可以对该方法进行适配的方式

### 9.7 接口中的域

- 接口中的域都自动是`static`和`final`的，所以可以用来当做创建常量组的工具，但是现在使用`enum(枚举类型)`更加合适，也更加强大
- 接口中的域在类第一次被加载时初始化，这发生在任何域首次被访问的时候
- 接口中的域不是接口中的一部分，它们的值存储在该接口的静态存储区域内

### 9.8 嵌套接口

- 接口可以嵌套在其它类或其它接口中
- 实现一个`private`接口可以强制该接口中的方法定义不要添加任何类型信息（也就是说，不允许向上转型）
- 嵌套在另一个接口中的接口自动就是`public`的，不能声明为`private`
- 当实现某个接口时，并不需要实现在嵌套在其内部的任何接口
- `private`接口不能在定义它的内之外被实现

### 9.9 接口与工厂

- 接口是实现多继承的途径，而生成遵循某个接口的对象的典型方式就是`工厂方法设计模式`
- 我们在工厂对象上调用的是创建**接口的某个实现的对象**的方法

### 9.10 总结

- 任何抽象性都应该是应真正的需求而产生的。当必须时，应该重构接口而不是到处添加额外级别的间接性，并且带来额外的复杂性
- 恰当的原则应该是优先选择类而不是接口，从类开始，如果接口的必需性变的非常明确，那么就进行重构



## 第 10 章 内部类

