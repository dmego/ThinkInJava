# Java 编程思想阅读笔记

## 第 1 章 对象导论



## 第 2 章 一切都是对象



## 第 3 章 操作符

### 操作符

- 操作符作用于一个操作数，生成一个新值。另外有些操作符可能会改变操作数自身的值，这被称为`副作用`。
- 几乎所有的操作符只能操作`基本类型`，例外的操作符是`=`，`==`，`!=`，这些操作符能操作所有对象。
- `String` 类支持 `+` 和 `+=` 操作。

### 优先级

- 先乘除后加减
- 如果忘记优先级规则，应该用括号明确规定计算顺序

### 赋值

- 赋值使用`=`，意思是`取右边的值（可以是任何常数、变量或者表达式，只要能生成一个值就行），把它赋值给左边（左边必须是一个明确的已命名的变量）`。
- 常数不能作为左值
- 基本类型的赋值操作是直接将一个地方的内容复制到另一个地方
- 对象的赋值操作其实复制的是一个对象的引用，但是引用指向的对象还是同一个对象——`别名现象`
- 在方法调用中也会遇到`别名问题`，因为在参数传递过程中，实际上传递的是对象的引用

### 算数操作符

- `+`、`-`、`*`、`/`、`%`。（`%`是取模操作符，从整数除法中产生余数）
- 整数除法会直接去掉小数位，不会进行四舍五入
- `Random`类对象在创建过程中如果没有传递任何参数作为随机数生成器的种子，那么将会默认使用当前时间作为种子。
- 一元加`+`、一元减`-`操作符可以让较小类型（如`byte、short`）的操作数提升为`int`类型，不过需要强制转换。

### 自动递增和递减

- 前缀递增`++a`和前缀递减`--a`会先执行运算，再生成值，也就是说先是`++a`的值加`1`，然后`a`的值才加`1`。
- 后缀递增`a++`和递减`a--`和前缀正好相反，先`a`的值加`1`，然后才是`a++`的值加`1`。也就是在运算执行前就会得到值。
- 它们是除了那些涉及赋值操作的操作符以外，唯一具有`副作用`的操作符，也就是说他们会改变操作数，而不仅仅是使用他们的值。

### 关系操作符

- 关系操作符生成一个`boolean`类型的结果，计算的是操作数之间的关系。
- 主要有`>`、`<`、`>=`、`<=`、`==`、`!=`等。
- `==`和`!=`同样适用于所有对象，因为他们比较的是对象的引用（尽管两个对象的内容一样，但是对象的引用不同，使用`==`时为`false`）。
- 如果想要比较两个对象的实际内容是否相同，可以使用`equals()`方法。由于`equals()`方法默认比较的还是引用，所以除非我们在自己的新类中覆盖这个方法，否则还是无法得到正确结果。
- 大多数 Java 类库都实现了`equals()`方法，以便用来比较对象的内容而不是引用。
- 基本类型不能用`equals()`来判断，可以直接使用`==`和`!=`。

### 逻辑操作符

- 逻辑操作符`与（&&）`、`或（||）`、`非（!)`，能根据参数的逻辑关系，生成一个布尔值。
- 逻辑操作符只可应用于布尔值，不可以将一个非布尔值当做布尔值在逻辑表达式中使用，这和`C/C++`中有所不同，在`C/C++`逻辑表达式中可以使用整数。
- 如果在该使用`String`值的地方使用了布尔值，布尔值会自动转换成对应的文本形式（`true/false`）。
- **短路现象**：一旦明确无误确定整个表达式的值，就不再计算表达式余下的部分了。例如在表达式 `test(1) && test(2) && test(3)`，中，如果`test(1)`计算出来为`false`，那么将不会计算`test(2)`和`test(3)`。（如果所有的逻辑表达式都有一部分不必计算，那将获得潜在的性能提升）。

### 直接常量

- 直接常量后缀字符标志了它的类型。`L/l`表示`long`、`F/f`表示`float`、`D/d`表示`double`。
- 十六进制以前缀`0x/0X`，后面跟随`0-9`或小写（大写）的`a-f`来表示。
- 八进制数由前缀`0`以及后续的`0~7`的数字来表示。
- **指数计数法**：`1.39e-43`表示`1.39x10^-43`，而`1.39e3`则表示`1.39x10^3`

### 按位操作符

- 按位操作符用来操作整数基本数据类型中的单个比特（bit）。按位操作符会对两个参数中对应的位执行布尔代数运算，最终生成一个结果。
  - 按位与`&`:两个参数的输入位都是`1`，则输出位也是`1`，否则是`0`，例如`1111 & 1010 = 1010`
  - 按位或`|`:输入位只要有一个是`1`，对应的输出位也是`1`，例如`1111 | 1010 = 1111`
  - 按位异或`^`:两个参数的位中，相同的结果为`0`，不同的结果为`1`，例如`1111 ^ 1010 = 0101`
  - 按位非`~`:按位取反操作，例如`~1010 = 0101`
- 按位操作符可与等号（=）联合使用，例如：`&=`、`|=`、`^=`，由于`~`是一元操作符，不能与`=`联合使用
- 对于布尔值，按位操作符和逻辑操作符具有相同的效果（不能执行`按位非`操作，对比下多了一个`按位异或`操作），只是它们不会中途`短路`。

### 移位操作符

- 移位操作符的运算对象也是二进制位，并且只可用来处理整数类型
  - 左移位操作符`<<`:将操作符左边的操作数`左移`右侧指定的位数（在低位补0），例如：`1010 << 2 = 101000`
  - `有符号`右移操作符`>>`:将操作符左边的操作数`右移`右侧指定的位数，右移操作符使用`符号扩展`，若符号为正，则在高位插入0；若符合为负，则在高位插入1。例如：`1010 >> 2 = 0010`、`11010 >> 2 = 11110`
  - `无符号`右移操作符`>>>`，它使用`零扩展`，无论正负，都在高位插入0；例如: `1010 >>> 2 = 0010`

- 如果对`byte`、`char`或`short`类型的数值进行移位操作，那么在移位之前会被转换成`int`类型，并且得到的结果也是`int`类型的。只有数值右端的低5位才有用，这样防止移位超过`int`类型所具有的位数（2^5 = 32 ，int 类型只有 32 位）。
- 若对`long`类型进行移位，最后会得到`long`类型的结果，此时只会用到数值右端的低6位，同样也是防止超过 long 类型的最大位数。
- 移位操作可以与`=`组合使用，例如：`<<=`、`>>=`、`>>>=`；但是在进行无符号右移位结合赋值操作时可能会出现问题：对`byte`或`short`类型进行右移位操作时，先转换成`int`类型，再进行位操作，操作完成后再赋值给原来的类型，这中间就要被`截断`，因为`int`类型大于`byte`和`short`类型，在这种情况下可能会得到`-1`的结果。
- 数字的二进制形式称为`有符号的二进制补码`。

### 三元操作符

- `boolean-exp ? value0 : value1`:如果布尔表达式（`boolean-exp`）为`true`，就计算`value0`的值并返回，如果表达式值为`false`，就计算`value1`的值并返回。
- 与普通的`if-else`语句一样，但是比较简练，也正是如此，如果频繁使用会让代码可读性变差

### 字符串操作符 + 和 +=

- 这个操作符在`Java`中主要用于连接不同的字符串
- `String + int + int + String`:在做输出时，经常使用 `+`操作符，这里就是用做字符串连接，这其中还涉及到类型转换，如果`+`前面是一个字符串类型，那么后面的所有类型都会自动转换为字符串类型，后面的`+`为连接操作符，而不是做算数运算。
- `S1 += S1`:将字符串`S2`追加到`S1`上
- `“”+int`:使用这种方式可以非常方便的将`int`类型转换为`String`类型。

### 类型转换操作符

- 类型转换（cast）原意是`模型锻造`，转换示例：`int i = 200; long l =(long)i; `。
- **窄化转换**：将容量较大的类型转换为容量较小的类型，例如`double`转`int`，这其中将会存在信息丢失的危险。在进行这样的转换时需要进行强制转换，也就是显示的进行转换。
- **扩展转换**：将容量较小的类型转换为容量较大的类型，例如`float`转`double`，对于这样的转换不需要显示的进行转换，Java会自动的进行类型转换。因为这其中不会涉及到信息丢失。
- **截尾和舍入**：在将`double`和`float`类型转换为整型时，总是对该数字进行`截尾处理`，也就是小数点后面的全部不要，如果想要进行四舍五入，可以使用`Math`中的`round()`方法。
- 通常，表达式中出现的最大数据类型决定了表达式最终结果的数据类型

### 注意点

- 如果对两个足够大的`int`类型进行乘法运算，结果会溢出，但是不会收到警告，异常或者是错误。
- 在进行`窄化转换`时要注意信息的丢失